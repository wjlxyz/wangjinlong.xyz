---
title: 【Java虚拟机规范】Java虚拟机结构：运行时数据区
categories:
    - '技术'
    - 'Java'
tags:
    - Java
    - 读书笔记
---

参考：《Java虚拟机规范》
<!--more-->



## PC寄存器

Java虚拟机可以支持多条线程同时执行，每一条Java虚拟机线程都有自己的pc寄存器。再任意时刻，一条Java虚拟机线程只会执行一个方法的代码，这个正在被线程执行的方法称为该线程的当前方法。

如果这个方法不是native的，那pc寄存器就保存Java虚拟机正在执行的字节码指令的地址，如果该方法是native的，那pc寄存器的值是undefined。pc寄存器的容量至少应当能保存一个returnAddress类型的数据或者一个与平台相关的本地指针的值。



## Java虚拟机栈

每一条Java虚拟机线程都有自己私有的Java虚拟机栈，这个栈与线程同时创建，用于存储栈帧。Java虚拟机栈用于存储局部变量与一些尚未算好的结果。另外它在方法调用和返回中也扮演了很重要的角色。因为除了栈帧的出栈和入栈之外，Java虚拟机栈不会再受其他因素的影响，所以栈帧可以在堆中分配，Java虚拟机栈所使用的内存不需要保证是连续的。

Java虚拟机实现应当提供给程序员或者最终用户调节虚拟机栈初始容量的手段，对于可以动态扩展和收缩Java虚拟机栈来说，则应当提供调节其最大、最小容量的手段。

Java虚拟机栈可能发生如下异常情况：

- 如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError异常；
- 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个OutOfMemoryError异常。



## Java堆

在Java虚拟机中，堆是可供各个线程共享的运行时内存区域，	也是供所有类实例和数组对象分配内存的区域。

Java堆在虚拟机启动的时候就被创建，它存储了被自动管理系统（也即常说的垃圾收集器）所管理的各种对象，这些受管理的对象无需也无法显式地销毁。虚拟机实现者可以根据系统的实际需要来选择自动内存管理技术。Java堆的容量可以是固定的，也可以随着程序执行的需求动态扩展，并在不需要过多空间时自动收缩。Java堆所使用的内存不需要保证是连续的。

Java虚拟机实现应当提供给程序员或者最终用户调节Java堆初始容量的手段，对于可以动态扩展和收缩Java堆来说，则应当提供调节其最大、最小容量的手段。

Java堆可能发生如下异常：

- 如果实际所需的堆超过了自动内存管理系统能提供的最大容量，那Java虚拟机将会抛出一个OutOfMemoryError异常。



## 方法区

在Java虚拟机中，方法区是可供各个线程共享的运行时内存区域。方法区与传统语言中的编译代码存储区或者操作系统进程的正文段的作用非常相似，它存储了每一个类的结构信息，例如，运行时常量池、字段和方法数据、构造函数和普通方法的字节码内容，还包括一些在类、实例、接口初始化时用到的特殊方法。

方法区在虚拟机启动的时候创建，虽然方法区是堆的逻辑组成部分，但是简单的虚拟机实现可以选择在这个区域不实现垃圾收集与压缩。方法区的容量可以是固定的，也可以随着程序执行的需求动态扩展，并在不需要过多空间时自动收缩。方法区在实际内存空间中可以是不连续的。

Java虚拟机实现应当提供给程序员或者最终用户调节方法区初始容量的手段，对于可以动态扩展和收缩方法区来说，则应当提供调节其最大、最小容量的手段。

方法区可能发生如下异常情况：

- 如果方法区的内存空间不能满足内存分配请求，那么Java虚拟机将抛出一个OutOfMemoryError异常。



## 运行时常量池

运行时常量池是class文件中每一个类或接口的常量池表的运行时表示形式，它包括了若干种不同的常亮，从编译期可知的数值字面量到必须在运行期解析后才能获得的方法或字段引用。运行时常量池类似于传统语言中的符号表，不过它存储数据的范围比通常意义上的符号表要更为广泛。

每一个运行时常量池都在Java虚拟机的方法区中分配，在加载类和接口到虚拟机后，就创建对应的运行时常量池。

在创建类和接口的运行时常量池时，可能会发生如下异常情况：

- 当创建类或接口时，如果构造运行时常亮池所需要的内存空间超过了方法区所能提供的最大值，那么Java虚拟机将会抛出一个OutOfMemoryError异常。



## 本地方法栈

Java虚拟机实现可能会使用到传统的栈来支持native方法的执行，这个栈就是本地方法栈。当Java虚拟机使用其他语言来实现指令集解释器时，也可以使用本地方法栈。如果Java虚拟机不支持native方法，或是本身不依赖传统栈，那么可以不提供本地方法栈，如果支持本地方法栈，那这个栈一般会在线程创建的时候按线程分配。

Java虚拟机规范允许本地方法栈实现成固定大小或者根据计算来动态扩展和收缩。如果采用固定大小的本地方法栈，那么每一个线程的本地方法栈容量可以在创建栈的时候独立选定。

Java虚拟机实现应当提供给程序员或者最终用户调节本地方法栈初始容量的手段，对于可以动态扩展和收缩方法区来说，则应当提供调节其最大、最小容量的手段。

本地方法栈可能发生如下异常情况：

- 如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError异常。
- 如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个OutOfMemoryError异常。